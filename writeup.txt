In designing the Dining Philosophers Problem in Rust, I focused on leveraging key concurrency features of the language to safely model philosophers, forks, and their interactions. Philosophers are modeled as asynchronous tasks that repeatedly think and eat, where eating requires access to forks. To handle this, I used tokio::sync::Semaphore to control access to the forks, ensuring that no more than two philosophers can eat at the same time. This prevents deadlocks and resource contention. Each philosopher runs as an independent task using tokio::spawn, which allows them to operate concurrently without blocking each other.

To track the number of times each philosopher eats and thinks, I used a shared Arc<Mutex<HashMap>> data structure, enabling thread-safe access across multiple tasks. The `Arc` ensures that the data is safely shared among asynchronous tasks, while the `Mutex` ensures that only one philosopher can update their statistics at a time, preventing race conditions. This approach ensures the simulation runs efficiently and safely. Additionally, I implemented a graceful shutdown mechanism using tokio::signal::ctrl_c() to allow the program to listen for a termination signal (like pressing Ctrl+C), cancel all philosopher tasks, and print out the statistics for each philosopher before exiting. Overall, the design effectively combines Rust's concurrency features with synchronization mechanisms to solve the Dining Philosophers Problem while preventing issues like deadlock and race conditions.